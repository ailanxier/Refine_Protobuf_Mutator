syntax = "proto3";
package xml;

// Simplified definition of XML formant according https://www.w3.org/TR/xml/
// Not all features are implemented and some rules are flattened.

// There are no required fields to allow backward compatibility with older
// corpus.

// document ::= prolog element Misc*
// prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
// XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
// doctypedecl ::=
//    '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'
message Document {
  // XMLDecl
  optional bytes version = 1;
  optional bytes encoding = 2;
  optional bool standalone = 3;

  repeated Misk misk1 = 4;
  optional DoctypeDecl doctype = 5;
  optional Element element = 6;
  repeated Misk misk2 = 7;
  uint64 test_uint64 = 8;
}

message DoctypeDecl {
  optional bytes name = 1;
  optional bytes external_id = 2;
  optional bytes int_subset = 3;
  repeated Misk misk = 4;
  uint32 test_uint32 = 5;
}

message Misk {
  oneof _ {
    Pi pi = 1;
    bytes comment = 2;
    double double_test = 3;
  }
}

// element ::= EmptyElemTag | STag content ETag
message Element {
  optional Tag tag = 1;
  // Use EmptyElemTag tag if missing, or STag and ETag otherwise.
  repeated Content content = 2;
}

// EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
// STag ::= '<' Name (S Attribute)* S? '>'
// ETag ::= '</' Name S? '>'
message Tag {
  optional bytes name = 1;
  repeated Attribute attribute = 2;
}

message Reference {
  optional bytes name = 1;
  optional bool entry = 2;
  int64 test_int64 = 3;
}

message Pi {
  optional bytes target = 1;
  optional bytes data = 2;
  float test_float = 3;
}

// content ::=
//    CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*
message Content {
  oneof _ {
    bytes char_data = 1;
    Element element = 2;
    Reference reference = 3;
    bytes cdsect = 4;
    Misk misk = 5;
  }
  enum testEnum {
    test1       = 0;
    test2       = 1;
    test3       = 4;
    test4       = 2;
    test5       = 3;
  }
  testEnum test = 6;
}

// Attribute ::=  Name Eq AttValue
message Attribute {
  optional bytes name = 1;
  optional bytes value = 2;
}

message Input {
  optional Document document = 1;

  // Option will be sent into libxml2 parser.
  // TODO(vitalybuka): Use proto extension. Options is libxml2 specific,
  // other libs may need different data. At the moment mutator does not support
  // extensions.
  optional uint32 options = 2;
}
