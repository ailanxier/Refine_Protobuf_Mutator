syntax = "proto3";
package OpenFHE;

// modes for RLWE schemes, such as BGV and BFV
enum SecretKeyDist {
    GAUSSIAN        = 0;
    UNIFORM_TERNARY = 1;
    SPARSE_TERNARY  = 2;
}
/*
* Rescale Operation:
* Whenever we multiply two ciphertexts c1 and c2 which encrypt numbers m1*D and m2*D respectively, 
* we get a result that looks like m1*m2*D^2. Since the scaling factor of this number is D^2, we say 
* that the result is of depth 2. It is clear that a ciphertext of depth 2 cannot be added to ciphertexts 
* of depth 1, because their scaling factors are different. Rescaling takes a ciphertext of depth 2, and 
* makes it of depth 1 by an operation that looks a lot like dividing by D=2^p.
*
* For efficiency reasons, our implementation of CKKS works in the RNS space, which means that we avoid 
* working with big numbers and we only work with native integers. One complication that arises
* from this is that we can only rescale by dividing by certain prime numbers and not D=2^p.
*
* ways to deal with this:
* 1.FIXEDMANUAL: choose prime numbers as close to 2^p as possible, and assume that the scaling factor 
* remains the same. This inevitably incurs some approximation error. 
* 2.FLEXIBLEAUTO: track how the scaling factor changes and try to adjust for it.
* 3.FIXEDAUTO: an automated version of FIXEDMANUAL that does all rescaling automatically.it hides all 
* the nuances of tracking the depth of ciphertexts and having to call the rescale operation. Therefore,
* FIXEDAUTO is more appropriate for users. On the contrary, FIXEDMANUAL is more appropriate for 
* production applications that have been optimized by experts.
*
*/
enum ScalingTechnique {
    FIXEDMANUAL          = 0;
    FIXEDAUTO            = 1;
    FLEXIBLEAUTO         = 2;
    FLEXIBLEAUTOEXT      = 3;
    NORESCALE            = 4;
    INVALID_RS_TECHNIQUE = 5;
};

enum KeySwitchTechnique {
    INVALID_KS_TECH = 0;
    BV              = 1;
    HYBRID          = 2;
};

enum SecurityLevel {
    HEStd_128_classic = 0;
    HEStd_192_classic = 1;
    HEStd_256_classic = 2;
    HEStd_NotSet      = 3;
};

enum EncryptionTechnique {
    STANDARD = 0;
    EXTENDED = 1;
};

enum MultiplicationTechnique {
    BEHZ             = 0;
    HPS              = 1;
    HPSPOVERQ        = 2;
    HPSPOVERQLEVELED = 3;
};

enum ProxyReEncryptionMode {
    NOT_SET              = 0;
    INDCPA               = 1;
    FIXED_NOISE_HRA      = 2;
    NOISE_FLOODING_HRA   = 3;
    DIVIDE_AND_ROUND_HRA = 4;
}
enum ExecutionMode {
    EXEC_EVALUATION       = 0;
    EXEC_NOISE_ESTIMATION = 1;
};

enum DecryptionNoiseMode {
    FIXED_NOISE_DECRYPT    = 0;
    NOISE_FLOODING_DECRYPT = 1;
}

message FHEParameter {
    uint32                  multiplicativeDepth     = 1;
    uint64                  plaintextModulus        = 2;
    // max batch size of messages to be packed in encoding (number of slots)
    uint32                  batchSize               = 3;
    /*
    * The digit size is only used in BV key switching and it allows us to perform digit decomposition * at a finer granularity. Under normal circumstances, digit decomposition is what we call
    * RNS decomposition, i.e., each digit is roughly the size of the qi's that comprise the 
    * ciphertext modulus Q. When using BV, in certain cases like having to perform rotations 
    * without any preceding multiplication, we need to have smaller digits to prevent noise 
    * from corrupting the result. In this case, using digitSize = 10 does the trick. 
    * set this to 0 (i.e., RNS decomposition) and see how the results are incorrect.
    */
    uint32                  digitSize               = 4;
    float                   standardDeviation       = 5;
    SecretKeyDist           secretKeyDist           = 6;
    int32                   maxRelinSkDeg           = 7;
    KeySwitchTechnique      ksTech                  = 8;
    ScalingTechnique        scalTech                = 9;
    uint32                  firstModSize            = 10;
    uint32                  numLargeDigits          = 12;
    uint32                  scalingModSize          = 14;
    SecurityLevel           securityLevel           = 15;
    uint32                  ringDim                 = 16;
    uint32                  evalAddCount            = 17;
    uint32                  keySwitchCount          = 18;
    EncryptionTechnique     encryptionTechnique     = 19;
    MultiplicationTechnique multiplicationTechnique = 20;
    uint32                  multiHopModSize         = 21;
    ProxyReEncryptionMode   PREMode                 = 22;
    ExecutionMode           executionMode           = 24;
    DecryptionNoiseMode     decryptionNoiseMode     = 25;
    double                  noiseEstimate           = 26;
    double                  desiredPrecision        = 27;
    double                  statisticalSecurity     = 28;
    double                  numAdversarialQueries   = 29;
    // features supported by public key encryption schemes
    bool                    PKE                     = 30;
    bool                    KEYSWITCH               = 31;
    bool                    PRE                     = 32;
    bool                    LEVELEDSHE              = 33;
    bool                    ADVANCEDSHE             = 34;
    bool                    MULTIPARTY              = 35;
    bool                    FHE                     = 36;
}